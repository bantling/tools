# Go Makefile

#### Change Make defaults

# Turn off default rules
.SUFFIXES:

# Silent, run "make VERBOSE=1 ..." to show output of each recipe invoked
ifndef VERBOSE
.SILENT:
endif

# Execute recipes with shell flags -eu, where:
# -e means die if any command fails with non-zero status
# -u means die if an undefined shell variable is referenced
.SHELLFLAGS := -eu

#### Variables

# The absolute path and dir to this Makefile
THIS_MAKEFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))
THIS_MAKEFILE_DIR  := $(patsubst %/,%,$(dir $(THIS_MAKEFILE_PATH)))

# golang docker image ref - see https://hub.docker.com/_/golang for tags
COMPILE_IMAGE_NAME := golang
COMPILE_IMAGE_VER  := 1.22.4-alpine3.20
COMPILE_IMAGE_REF  := $(COMPILE_IMAGE_NAME):$(COMPILE_IMAGE_VER)

# alpine docker image ref - see https://hub.docker.com/_/alpine for info, has a latest tag
RUN_IMAGE_NAME := alpine
RUN_IMAGE_VER  := latest
RUN_IMAGE_REF  := $(RUN_IMAGE_NAME):$(RUN_IMAGE_VER)

# generated image
DEPLOY_IMAGE_NAME := hello
DEPLOY_IMAGE_VER  := 1.0 
DEPLOY_IMAGE_REF  := $(DEPLOY_IMAGE_NAME):$(DEPLOY_IMAGE_VER)

# Dir of source code
SRC_DIR := $(THIS_MAKEFILE_DIR)/src

# Cache dir to store compiled results across builds
GO_CACHE_DIR := $(THIS_MAKEFILE_DIR)/.cache

# The absolute dir for caching docker package dependencies pulled in by "go mod tidy"
GO_CACHE_PKG   := $(GO_CACHE_DIR)/pkg

# The absolute dir for caching docker build artifacts generated by "go build ./..."
GO_CACHE_BUILD := $(GO_CACHE_DIR)/build

#### Targets

# Default target
.PHONY: all
all: vars podman $(GO_CACHE_DIR) oci

# Ensure podman is up so we can use it to build containers
.PHONY: podman
podman: podman-path podman-machine-init podman-machine-start

# Ensure podman is in the path
.PHONY: podman-path
podman-path:
	echo ">>> Checking if podman is in path"
	which podman > /dev/null 2> /dev/null || { \
	  echo "podman is not installed, or not in your path"; \
	  exit 1; \
	}

# Ensure podman has been initialzed
.PHONY: podman-machine-init
podman-machine-init:
	echo ">>> Checking of podman has been intialized"
	[ "`podman machine list --format "{{.Name}}" | wc -l`" -ge 1 ] || { \
	  echo "Initializing podman"; \
	  podman machine init; \
	}

# Ensure podman has been started 
.PHONY: podman-machine-start
podman-machine-start:
	echo ">>> Checking if podman has been started"
	[ "`podman machine list --format "{{.LastUp}}" | grep -i running | wc -l`" -ge 1 ] || { \
	  echo "Starting podman"; \
	  podman machine start; \
	}

# Ensure all oci container building operations are performed, so we have all the containers we need to run the app
.PHONY: oci
oci: oci-clean oci-pull oci-build oci-run

# Clean oci artifacts: remove all containers related to the image, and the image itself
# The only thing not removed is the base image needed to build the code
.PHONY: oci-clean
oci-clean:
	echo ">>> Cleaning previously generated app OCI images and containers"
	for id in `podman ps -a --format '{{.ID}} {{.Image}}' | grep $(DEPLOY_IMAGE_REF) | awk '{print $$1}'`; \
	do \
	  echo "Removing container $$id"; \
	  podman rm "$$id"; \
	done
	for id in `podman image ls --format '{{.ID}} {{.Repository}}:{{.Tag}}' | grep $(DEPLOY_IMAGE_REF) | awk '{print $$1}'`; \
	do \
	  echo "Removing image $$id"; \
	  podman image rm "$$id"; \
	done

# Pull oci compile and run images
.PHONY: oci-pull
oci-pull:
	echo ">>> Checking if app compile and run images need to be pulled"
	[ "`podman image list --format "{{.ID}}" --filter "reference=$(COMPILE_IMAGE_REF)" | wc -l`" -gt 0 ] || { \
	  echo "Pulling compile image"; \
	  podman pull $(COMPILE_IMAGE_REF); \
	}
	[ "`podman image list --format "{{.ID}}" --filter "reference=$(RUN_IMAGE_REF)" | wc -l`" -gt 0 ] || { \
	  echo "Pelling run image"; \
	  podman pull $(RUN_IMAGE_REF); \
	}

# Ensure package and compiled object cache dirs exist
$(GO_CACHE_PKG) $(GO_CACHE_BUILD):
	echo ">>> Creating app package and build cache dirs"
	mkdir -p "$@"

# Build oci image
# Pruning removes the unnamed initial stage images of multi stage builds
.PHONY: oci-build
oci-build: Containerfile | $(GO_CACHE_PKG) $(GO_CACHE_BUILD)
	echo ">>> Building app image"
	podman build \
	  --build-arg "COMPILE_IMAGE_REF=$(COMPILE_IMAGE_REF)" \
	  --build-arg "RUN_IMAGE_REF=$(RUN_IMAGE_REF)" \
	  -v "$(SRC_DIR):/src" \
	  -v "$(GO_CACHE_PKG):/go/pkg/mod" \
	  -v "$(GO_CACHE_BUILD):/root/.cache" \
	  -t $(DEPLOY_IMAGE_REF) \
	  .
	podman system prune -f

# Run oci container
# Ignore errors from run, assume user hit CTRL-C to stop it
.PHONY: oci-run
oci-run:
	echo ">>> Running app container. To stop, hit Ctrl-C or run curl localhost:8000/quit"
	podman run --rm --name=$(DEPLOY_IMAGE_NAME) -p 8000:8000 $(DEPLOY_IMAGE_REF) || :

# git push
.PHONY: push
push:
	echo ">>> Pushing all changes to git"
	git add -A
	git commit -am Changes
	git push

.PHONY: vars
vars:
	echo ">>> Displaying variables"
	echo "THIS_MAKEFILE_PATH = $(THIS_MAKEFILE_PATH)"
	echo "THIS_MAKEFILE_DIR  = $(THIS_MAKEFILE_DIR)"
	echo "COMPILE_IMAGE_NAME = $(COMPILE_IMAGE_NAME)"
	echo "COMPILE_IMAGE_VER  = $(COMPILE_IMAGE_VER)"
	echo "COMPILE_IMAGE_REF  = $(COMPILE_IMAGE_REF)"
	echo "RUN_IMAGE_NAME     = $(RUN_IMAGE_NAME)"
	echo "RUN_IMAGE_VER      = $(RUN_IMAGE_VER)" 
	echo "RUN_IMAGE_REF      = $(RUN_IMAGE_REF)"
	echo "DEPLOY_IMAGE_NAME  = $(DEPLOY_IMAGE_NAME)"
	echo "DEPLOY_IMAGE_VER   = $(DEPLOY_IMAGE_VER)" 
	echo "DEPLOY_IMAGE_REF   = $(DEPLOY_IMAGE_REF)"
	echo "SRC_DIR            = $(SRC_DIR)"
	echo "GO_CACHE_DIR       = $(GO_CACHE_DIR)"
	echo "GO_CACHE_PKG       = $(GO_CACHE_PKG)"
	echo "GO_CACHE_BUILD     = $(GO_CACHE_BUILD)"
