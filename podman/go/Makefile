# Demo of using podman on Windows, Mac, or Linux

#### Change Make defaults

# Turn off default rules
.SUFFIXES:

# Silent, run "make VERBOSE=1 ..." to show output of each recipe invoked
ifndef VERBOSE
.SILENT:
endif

# Execute all recipe lines as a single shell invocation
.ONESHELL:

# Execute recipes with shell flags -eu, where:
# -e means die if any command fails with non-zero status
# -u means die if an undefined shell variable is referenced
.SHELLFLAGS := "-eu"

#### Variables

# The absolute path and dir to this Makefile
THIS_MAKEFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))
THIS_MAKEFILE_DIR  := $(patsubst %/,%,$(dir $(THIS_MAKEFILE_PATH)))

# golang docker image ref - see https://hub.docker.com/_/golang for latest release that is not rc, beta, etc
BASE_IMAGE_NAME := "golang"
BASE_IMAGE_VER  :=  "1.22.4-alpine3.20""
BASE_IMAGE_REF  := "$(BASE_IMAGE_NAME):$(BASE_IMAGE_VER)"

# generated image
IMAGE_NAME := "hello"
IMAGE_VER  := "1.0" 
IMAGE_REF  := "$(IMAGE_NAME):$(IMAGE_VER)"

# Cache dir to store compiled results across builds
GO_CACHE_DIR := $(THIS_MAKEFILE_DIR)/.cache

# The absolute dir for caching docker package dependencies pulled in by "go mod tidy"
DOCKER_GO_CACHE_PKG   := $(GO_CACHE_DIR)/pkg

# The absolute dir for caching docker build artifacts generated by "go build ./..."
DOCKER_GO_CACHE_BUILD := $(GO_CACHE_DIR)/build

#### Targets

# Default target
.PHONY: all
all: podman $(GO_CACHE_DIR) oci

# Ensure podman is up so we can use it to build containers
.PHONY: podman
podman-up: podman-path podman-machine-init podman-machine-start

# Ensure podman is in the path
.PHONY: podman-path
podman-path:
	which podman > /dev/null 2> /dev/null || {
	  echo "podman is not installed, or not in your path"
	  exit 1
	}

# Ensure podman has been initialzed
.PHONY: podman-machine-init
podman-machine-init:
	[ "`podman machine list --format "{{.Name}}" | wc -l`" -ge 1 ] || {
	  echo "Initializing podman"
	  podman machine init
	}

# Ensure podman has been started 
.PHONY: podman-machine-start
podman-machine-start:
	[ "`podman machine list --format "{{.LastUp}}" | grep -i running | wc -l`" -ge 1 ] || {
	  echo "Starting podman"
	  podman machine start
	}

# Ensure cache dir for go ccompiled objects exists
$(GO_CACHE_DIR):
	mkdir -p "$@"

# Ensure all oci container building operations are performed, so we have all the containers we need to run the app
.PHONY: oci
oci: oci-clean oci-pull oci-build oci-run

# Clean oci artifacts: remove all containers related to the image, and the image itself
# The only thing not removed is the base image needed to build the code
.PHONY: oci-clean
clean:
	for id in `podman ps -a --format "{{.ID}} {{.Image}}" | grep IMAGE_REF | awk '{print $$1}'`
		echo "Removing container $$id"
		podman rm "$$id"
	done
	for id in `podman image ls --format '{{.ID}} {{.Repository}}:{{.Tag}}' | grep IMAGE_REF | awk '{print $$1}'`; do
		echo "Removing image $$id"
		podman image rm "$$id"
	done

# Pull oci base image
.PHONY: oci-pull
oci-pull:
	[ `podman image list --format "{{.ID}}" --filter "reference=$(IMAGE_REF)" | wc -l` -eq 1 ] ||
	  podman pull $(IMAGE_REF)

# Build oci image
oci-build: app/main.go Containerfile
	podman build --build-arg "BASE_IMAGE_REF=$(BASE_IMAGE_REF)" \
	  -t IMAGE_REF \
	  -v $(PODMAN_GO_CACHE_PKG):/go/pkg/mod \
	  -v $(PODMAN_GO_CACHE_BUILD):/root/.cache
	touch $@

# Run oci image
.PHONY: oci-run
oci-run:
	podman run --name=IMAGE_NAME -v $$(pwd)/app:/app IMAGE_REF

# git push
.PHONY: push
push:
	git add -A
	git commit -am Changes
	git push
