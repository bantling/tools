// SPDX-License-Identifier: Apache-2.0
:doctype: article

= ASCIIDOC strategies

== top-level-readme

A strategy for the top level README.adoc file of a project.
The layout is suitable for GitLab or GitHub to automatically render it when viewed.
There can be links to both static images stored in the repo and images generated by various graphing tools.

=== Required software

The following Arch Linux packages need to be installed to provide the necessary cli tools
(the package name is the same as the cli tool provided, except where noted):

* asciidoc
* dblatex
* ditaa
* graphviz (provides dot command)
* inkscape   
* pandoc
* plantuml
* xmlstarlet

=== Layout

[cols=3*]
|===
| Path
| Purpose
| Checked In

| README.adoc
| Project README
| Yes

| docs
| Folder for all documentation files
| Yes

| docs/readme
| Folder for project README files
| Yes

| docs/readme/Makefile
| Make file to generate images and output files
| Yes

| docs/readme/src
| Source files for generated images
| Yes

| docs/readme/img
| Static and generated images
| Yes

| docs/readme/build
| Temporary files for build process
| No

| docs/readme/out
| Self-contained output files
| No
|===

GitLab/github can auto render the html for a project README.adoc file of a repo.

* adoc refers to static images (jpg, png, etc) in docs/readme/img
* adoc refers to generated svg images for graphs (dot, ditaa, uml, etc) in docs/readme/img
* svg images are generated by cli tools

=== Makefile variables

[cols=2*]
|===
| Name
| Value

2+| Source files

| SRC_ADOC
| ../../README.adoc

| SRC_IMG
| src/*.+++{jpg, png}+++

| SRC_DOT
| src/*.dot

| SRC_DITAA
| src/*.ditaa

| SRC_UML
| src/*.uml

2+| Generated svg files

| DST_DOT_SVG
| src/*.dot.svg

| DST_DITAA_SVG
| src/*.ditaa.svg

| DST_UML_SVG
| src/*.uml.svg

| DST_IMG_SVG
| src/*.+++{dot, ditaa, uml}+++.svg

2+| Generated pdf files

| DST_DOT_PDF
| src/*.dot.pdf

| DST_DITAA_PDF
| src/*.ditaa.pdf

| DST_UML_PDF
| src/*.uml.pdf

| DST_IMG_PDF
| src/*.+++{dot, ditaa, uml}+++.pdf

2+| Generated emf files

| DST_DOT_EMF
| src/*.dot.emf

| DST_DITAA_EMF
| src/*.ditaa.emf

| DST_UML_EMF
| src/*.uml.emf

| DST_IMG_EMF
| src/*.+++{dot, ditaa, uml}+++.emf

2+| Generated output files

| DST_HTML
| out/README.html

| DST_PDF
| out/README.pdf

| DST_DOCX
| out/README.docx
|===

=== Makefile targets

[cols=2*]
|===
| Name
| Purpose

2+| Default

| all
| Generate all outputs

2+| Directories for artifacts

| build
| Create build dir

| out
| Create out dir

2+| Generate outputs

| $(DST_HTML)
| Generate out/README.html

| $(DST_PDF)
| Generate out/README.pdf

| $(DST_DOCX)
| Generate out/README.docx

2+| Generate svg images

| img/%.dot.svg
| Generate svg files from .dot sources

| img/%.ditaa.svg
| Generate svg files from .ditaa sources

| img/%.uml.svg
| Generate svg files from .uml sources

2+| Generate pdf images

| build/%.dot.pdf
| Generate pdf images from img/%.dot.svg images

| build/%.ditta.pdf
| Generate pdf images from img/%.ditaa.svg images

| build/%.uml.pdf
| Generate pdf images from img/%.uml.svg images

2+| Generate emf images

| build/%.dot.emf
| Generate emf images from img/%.dot.svg images

| build/%.ditta.emf
| Generate emf images from img/%.ditaa.svg images

| build/%.uml.emf
| Generate emf images from img/%.uml.svg images

2+| Other tasks

| vars
| Dump all var names and values to the console

| clean
| Remove build and out dirs and their contents
|===

=== Make functions and special variables

* The SRC_+++{IMG, DOT, DITAA, UML}+++ variables have definitions that use the wildcard function, such as:
+
....
SRC_IMG       := $(wildcard img/*.jpg) $(wildcard img/*.png)
....
+
The wildcard function is like an `ls` command. So SRC_IMG is a list of all .jpg and .png files in the img dir.
+
* The DST_+++{DOT, DITAA, UML}_SVG+++ variables use pattern substitutions, such as:
+
....
DST_DOT_SVG   := $(SRC_DOT:src/%=img/%.svg)
....
+
The `src/%=img/%.svg` substitution means that for every src/X file in the SRC_DOT variable, produce an img/X.svg file in DST_DOT_SVG.
Note that the `%` can span directories, and that the `%.svg` adds an additional .svg extension to the file name.
+
The reason for producing filenames like `X.dot.svg` is so that Make can distinguish between .svg files generated from .dot sources,
.svg files generated from .ditaa sources, and .svg files generated from .uml sources.
+
This is necessary because .dot, .ditaa, and .uml sources require different binary programs to generate svg files.
+
* `$<` refers to the first prerequisite, and `$@` refers to the file being generated:
+
....
$(DST_HTML): $(SRC_ADOC) $(DST_IMG_SVG) build out
    asciidoc -b html -o $@ $<
....
+
In this case, `$<` refers to `$(SRC_ADOC)` and `$@` refers to `$(DST_HTML)`.
So for a file named `../../README.adoc`, we produce a file named `out/README.html` with the following command:
+
....
asciidoc -b html -o out/README.html ../../README.adoc
....
 
=== SVG generation of .dot files

Makefile rule:
....
img/%.dot.svg: src/%.dot
    dot -Tsvg $< -o$@
....

The dot command requires that the `-o` option has the output filename tight against it with no space between.
The .dot format includes a title in the first line, eg:

....
digraph "A digraph" {
....

In this example, the title is "A digraph", which will automatically be translated into an svg title element by the dot command.
The svg title has two use cases:

* When rolling your mouse over the image and hover, the title appears
* It makes the document better for accessibility
 
=== SVG generation of .ditaa files

Makefile rule:
....
img/%.ditaa.svg: src/%.ditaa
    title="`grep -Po '(?<=image::docs/readme/$@\[")[^"]*' $(SRC_ADOC)`"; \
        ditaa --svg $< - -T -r | \
        xmlstarlet ed -u "/*/@width" --value "540pt" | \
        xmlstarlet ed -i "/*/*[1]" -t elem -n title -v "$$title" > $@
....

The ditaa command does not generate an svg title element.
The `title=...` line sets a bash var named `title` to the alt text of the link in the README.adoc.  
The link in the adoc file looks like this:

....
image::docs/readme/img/memory.ditaa.svg["Memory"]
....

Where `title` is set to the text `Memory` in this case.
The grep command works as follows:

* `-P`: use Perl regex, allowing positive and negative lookahead and lookbehind
* `-o`: grab only the matched portion of the line instead of all of it
* `(?<=image::docs/readme/$@\[")`: positive look behind for `image::docs/readme/img/X.ditaa.svg[`
* `[^"]*`: matches all characters after `["` up to but not including next `"`, which is `Memory`, and is the only text returned

The ditaa command arguments are:

* `--svg`: generate svg output
* `$<`: `src/%.ditaa` input file
* `-`: write svg to standard output
* `-T`: svg has transparent background
* `-r`: use rounded corners for boxes

The svg file is an xml file. The root element width is sometimees too narrow, causing text to be cut off.   
To solve this, `xmlstarlet` is used to modify the xml, with the following arguments:

* `ed`: edit the xml
* `-u`: update an attribute or element
* `"+++/*/@width+++"`: the `/*/` is a way to refer to the root element when namespaces are used, `@width` means width attribute
* `--value "540pt"``: set the value of width attribute to 540 points, where a point is 1/72 of an inch

It seems xmlstarlet can only edit one part of the xml, but we also want to insert a title element.
So we pipe the output to another xmlstarlet command:

* `ed`: edit the xxml
* `-i`: insert a new element or attribute
* `"+++/*/*[1]+++"`: insert before the first child of the root element, without knowing the element name of the child
* `-t elem`: insert an element
* `-n title`: the element name is `title`
* `v "$$title"`: the title content is the value of the bash `$title` var (`Memory`).
In bash, the var name is just `$title`, when using bash in Make, we use two `$` to indicate that title is a bash var, not a Make var.  

The final `> $@` writes the standard output of second xmlstarlet command to the output file (img/memory.ditaa.svg).

=== SVG generation of .uml files

Makefile rule:
....
img/%.uml.svg: src/%.uml
    plantuml -tsvg $<
    mv $(<:%.uml=%.svg) $@
    title="`grep -Po '(?<=image::docs/readme/$@\[")([^"]*)' $(SRC_ADOC)`"; \
        xmlstarlet ed --inplace -i "/*/*[1]" -t elem -n title -v "$$title" $@
....

The plantuml command, like ditaa, does not generate an svg title.
The command arguments are:

* `-tsvg`: generate svg
* `$<`: source uml text file

The command does not allow specifying the target file, instead it generates a file with same name as source in the same dir,
just replacing the extension with .svg. As such, the `mv` command renames the file to the expected target path.

The line that sets the `title` bash var is identical to the line used for ditaa files.

The usage of `xmlstarlet` to set the svg title is similar to the ditaa generation, with one minor exception: +
the `+++--inplace+++` argument indicates to modify the target file directly. 

=== PDF and EMF generation of .dot files

The make rules for PDF and EMF generation are extremely simple one liners like this:

....
build/%.dot.pdf: img/%.dot.svg build
    inkscape -o $@ $<
....

The `inkscape` command is used to simply read in the svg file generated as above, and convert it to a PDF or EMF file.

The reason for creating PDF images is that when generating a PDF document with links to svg, the svgs simply disappear from the pdf.
By generating PDF images, they just get copied into the target PDF document. PDF has drawing commands, so the resulting
document is still a vector format.

Similarly, EMF is used for DOCX simply because while Microsoft claims that you can embed PDF and EPS in a DOCX, that just
isn't the case. EMF is Microsoft's own vector format, and not surprisingly, is the only vector format that actually works embedded in a DOCX.

=== Self-contained HTML

Makefile rule:

....
$(DST_HTML): $(SRC_ADOC) $(DST_IMG_SVG) build out
    asciidoc -b html -o $@ $<
    for i in $(SRC_IMG); do \
        title="`grep -Po '(?<=image::docs/readme/'$$i'\[")[^"]*' $(SRC_ADOC)`"; \
        ext="`echo $$i | sed 's,.*[.],,'`"; \
        echo -n '<img src="data:image/'$$ext';base64,' > build/tmp.b64; \
        base64 -w 0 $$i >> build/tmp.b64; \
        echo -n '" alt="'$$title'"/>' >> build/tmp.b64; \
        sed -i '\,<img src="docs/readme/'$$i'"[^/]*/>,r build/tmp.b64' $@; \
        sed -i '\,<img src="docs/readme/'$$i'"[^/]*/>,d' $@; \
    done; \
    for i in $(DST_IMG_SVG); do \
        sed -n '/<svg/,$$p' $$i > build/tmp.svg; \
        sed -i '\,<img src="docs/readme/'$$i'"[^/]*/>,r build/tmp.svg' $@; \
        sed -i '\,<img src="docs/readme/'$$i'"[^/]*/>,d' $@; \
    done
....

This is the most complex make rule, that does the following:

* Generate an html file
* Replace every static image link (jpg or png) into an embedded image of the following form:
+
....
<img src="data:image/jpg;base64,<base 64 data>" alt="Alt Text"/>
....
+
* Replace every generated svg image link with an svg element

asciidoc command arguments are:

* `-b html`: target format is html
* `-o $@`: write to `$@` target file (out/README.html)
* `$<`: source adoc file to convert `$(SRC_ADOC)` = (../../README.adoc) 

The first for loop replaces static image links with an embedded base64 image:

* The `title=` line grabs the image title exactly the same way as for ditaa and uml svg images.
* The `ext=` line grabs the file extension without the dot (jpg, png)
* The first `echo -n` line writes `<img src="data:image/{jpg,png};based64,` to a temp file `build/tmp.b64`
* The `base64` line appends a single line of base64 data to the temp file
* The second `echo -n` line appends `" alt="{title}"/>` to the temp file
* The first `sed -i` line appends the content of the temp file after the original generated img tag in the html file
* The second `sed -i` line deletes original generated img tag from the html file

For `echo`, the `-n` argument suppresses the trailing newline.

The first `sed` command works as follows:

* The `-i` means modify the file in place rather than writing to standard out
* The `\,` means search for a regex match using a comma delimiter
* The `<img src="docs/readme/'$$i'"[^/]*/>,` says to search for an img tag whose src attribute is the particular static image of interest
** The `'$$i'` drops out of single quote mode, outputs the value of the bash for loop variable, then reenters single quote mode   
** The trailing comma delimits the end of the regex
** The `r build/tmp.b64` is the command to append the contents of the temp file on the next line after the img tag in the html file.

The second `sed` command has the identical regex match, and deletes the original img tag so the only tag left for the static image is the base64 version.

The second for loop replaces generated svg image links with an svg element.
An svg file on disk is an xml file, the only difference between it and an html svg element is that the file contains an xml preamble.
The preamble is generated slightly differently by each tool, but they all place the root svg element on a new line after the preamble.
The strategy is the same for all generated svgs:

* Remove the premable that comes before the opening root svg tag, writing the content to a temp file
* Use the same two sed command approach as for static images to append the temp file after the original img tag, then remove the original img tag  

The preamble looks like this for a generated dot file:

....
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.49.1 (0)
 -->
<!-- Title: A digraph Pages: 1 -->
<svg width="188pt" height="116pt"
....

The following sed command removes the premable:

....
sed -n '/<svg/,$$p' $$i > build/tmp.svg; \
....

It works as follows:

* The `-n` argument means don't print any lines automatically, only print what we explicitly state to print
* The `/<svg/` is a regex match for any lines that contain `<svg`, there is only one such line
* The `,$$p` is seen by bash as `,$p`, where the `$p` command means to print this matching line and all lines after it.
Since the `$p` is inside single quotes, bash does not interpret it as a variable named p, instead sed receives the literal text `$p`.

With the replacement of all image links with embedded content, the HTML file becomes self-contained, you can open the file
by itself in a browser with no other files available and view it correctly.

=== Self-contained PDF

Makefile rule:

....
$(DST_PDF): $(SRC_ADOC) $(DST_IMG_PDF) out
    sed -r 's,(image::)docs/readme/,\1,;s,img/(.*).svg,build/\1.pdf,' $< | \
        asciidoc -b docbook -o - - | \
        dblatex -T db2latex -P doc.layout="toc mainmatter" -tpdf -o $@ -
....

The `sed` command writes a modified copy of the ../../README.adoc to standard output, where the asciidoc image links are
updated to point to the generated pdf images rather than the generated svg images. It works as follows:

* The `-r` means interpret round and square brackets as their regex meaning, rather than as literal characters
* The `s,(image::)docs/readme/,\1,` searches for a regex delimted by commas. The regex matches  `image::docs/readme/`, and
replaces it with just `image::`
* The `;` is a separator that ends the first command
* The `+++s,img/(.*).svg,build/\1.pdf,+++` searches for `+++img/.*.svg+++`, and replaces it with `+++img/.*.pdf+++`.
The round brackets in `+++(.*).svg+++` captures the filename before the .svg, and the `\1` in the replacement refers to capture group 1. 

The `asciidoc` command is similar to generating html, the only differences are:

* The input and output files are both `-`, indicating it reads the standard output of the sed command as input, and writes output to standard out
* It generates docbook output, which is a format that can contain anything you'd expect in a book (table of contents, index, etc)

The `dblatex` command takes docbook input and produces latex or pdf output, with the following args:

* `-T db2latex` specifies the style of output, it is closer to the html then the default styling
* `-P doc.layout="toc mainmatter"` sets the doc.layout property, which specifies what portions of output we want.
The default output includes a cover page, revision history, and list of contributors, which we don't need.
* `-tpdf` produces pdf output
* `-o $@` writes output to target file (out/README.pdf)
* `-` reads docbook input from standard input

=== Self-contained DOCX

Makefile rule:

....
$(DST_DOCX): $(SRC_ADOC) $(DST_IMG_EMF) out
    sed -r 's,(image::)docs/readme/,\1,;s,img/(.*).svg,build/\1.emf,' $< | \
        asciidoc -b docbook -o - - | \
        pandoc -f docbook -t docx -o $@ --toc
....

* The `sed` command works identically to PDF generation, except that it expects links to emf images rather then pdf images
* The `asciidoc` is exactly the same as for PDF generation

The `pandoc` commmand generates the DOCX file, with the following args:

* `-f docbook` means translating from docbook format
* `-t docx` means translating to DOCX format
* `-o $@` writes outoput to target file (out/README.docx)
* `--toc` includes a table of contents
