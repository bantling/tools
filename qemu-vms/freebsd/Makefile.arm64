# // SPDX-License-Identifier: Apache-2.0

# Build a FreeBSD aarch64 bootable image with the following basic steps:
# - Determine latest release of FreeBSD memstick image
# - Download latest release and hash file
# - Generate a hash file, and commpare against downloaded hash file
# - Make a copy of memstick image
# - EFI boot copy of memstick
# - Modify memstick image so that it has autologin, and a bootstrap script
# - Run bootstrap script to modify a second drive that is an installer
# - Auto powers off once installer is setup
# - EFI boot installer image to install into a test image
# - User manually runs installer, and powers off
# - EFI boot test image to verify it boots up, user can login on and poweroff

# Execute all recipe lines in one shell
.ONESHELL:

# Turn off default rules
.SUFFIXES:

# We need a target to determine the latest release version of FreeBSD
# This is a nuisance because there may be a beta version that is newer than the current release
# EG:
# We grab contents of https://download.freebsd.org/releases/arm64/aarch64/ISO-IMAGES:
#
# 12.4/
# 13.2/
# 13.3/
# 14.0/
# 14.1/
#
# But if we list contents of https://download.freebsd.org/releases/arm64/aarch64/ISO-IMAGES/14.1, we see it is a beta:
# FreeBSD-14.1-BETA1-arm64-aarch64-memstick.img.xz
#
# So we need to fall back on the previous 14.0 version:
# FreeBSD-14.0-RELEASE-arm64-aarch64-memstick.img.xz
#
# Eventually, the 14.1 beta will be replaced by a release, and the script will use that instead if 14.0

# URL to get available versions of FreeBSD
ARM64_ISO_BASE_URL := https://download.freebsd.org/releases/arm64/aarch64/ISO-IMAGES

# Define a script to get the latest x86 RELEASE version
define ARM64_GET_RELEASE
for version in $$(curl -sL $(ARM64_ISO_BASE_URL) | grep '<a href="[0-9]' | sed -r 's,.*href="([^/]*)/.*,\1,' | sort -rV); do
	[ $$(curl -sL $(ARM64_ISO_BASE_URL)/$$version | grep 'href="FreeBSD.*RELEASE' | wc -l) -gt 0 ] || continue;
	echo $$version;
	break;
done
endef

# Define release vars
ARM64_RELEASE         := $(shell $(ARM64_GET_RELEASE))
ARM64_RELEASE_F       := .arm64.release
ARM64_XZ_URL          := $(ARM64_ISO_BASE_URL)/$(ARM64_RELEASE)/FreeBSD-$(ARM64_RELEASE)-RELEASE-arm64-aarch64-memstick.img.xz
ARM64_MEMSTICK        := .arm64-memstick.img
ARM64_XZ_MEMSTICK     := $(ARM64_MEMSTICK).xz
ARM64_XZ_CKSUM_URL    := $(ARM64_ISO_BASE_URL)/$(ARM64_RELEASE)/CHECKSUM.SHA512-FreeBSD-$(ARM64_RELEASE)-RELEASE-arm64-aarch64
ARM64_XZ_CKSUM        := .arm64.sha512
ARM64_XZ_CKSUM_GEN    := $(ARM64_XZ_CKSUM).gen
ARM64_XZ_CKSUM_CMP    := $(ARM64_XZ_CKSUM).cmp
ARM64_RETRO           := arm64.retro.qcow2
OVMF_REPO             := rust-osdev/ovmf-prebuilt
OVMF_API              := https://api.github.com/repos/$(OVMF_REPO)
OVMF_RELEASE          := $(shell curl -s $(OVMF_API)/releases | jq -r '.[].tag_name' | grep stable | head -n 1)
OVMF_RELEASE_F        := .edk2.release
OVMF_DOWNLOAD         := https://github.com/$(OVMF_REPO)/releases/download/$(OVMF_RELEASE)/$(OVMF_RELEASE)-bin.tar.xz
OVMF_TAR_XZ           := .edk2.tar.xz
OVMF_TAR_AARCH64_CODE := $(OVMF_RELEASE)-bin/aarch64/code.fd
OVMF_TAR_AARCH64_VARS := $(OVMF_RELEASE)-bin/aarch64/vars.fd
ARM64_OVMF_CODE       := .arm64.OVMF_CODE.fd
ARM64_OVMF_VARS       := .arm64.OVMF_VARS.fd
ARM64_RETRO_INST      := .arm64.retro.inst


# Define other vars
COMMA                        := ,
QEMU_ACCEL_HVF               := $(shell qemu-system-aarch64 -accel help | grep hvf)
QEMU_ACCEL_WHPX              := $(shell qemu-system-aarch64 -accel help | grep whpx)
QEMU_ACCEL_KVM               := $(shell qemu-system-aarch64 -accel help | grep kvm)
QEMU_ACCEL                   := $(if $(QEMU_ACCEL_HVF),hvf,$(if $(QEMU_ACCEL_WHPX),whpx$(COMMA)kernel-irqchip=off,$(if $(QEMU_ACCEL_KVM),kvm,tcg)))
ARM64_IMAGE_INSTALL          := arm64.install.img
ARM64_IMAGE_TEST             := arm64.test.img
ARM64_IMAGE_TEST2            := arm64.test2.img

# Silent by default
# Run "make VERBOSE=1 ..." to show output of each recipe invoked
ifndef VERBOSE
.SILENT:
endif

# Default target
.PHONY: all
all: generate-freebsd-release generate-edk2-release run

# Generate the release file if:
# - It does not exist
# - It contains a different version that the current one
.PHONY: generate-freebsd-release
generate-freebsd-release:
	echo 'Checking FreeBSD release'
	[ -f "$(ARM64_RELEASE_F)" -a "`cat "$(ARM64_RELEASE_F)" 2> /dev/null`" = "$(ARM64_RELEASE)" ] || echo "$(ARM64_RELEASE)" > "$(ARM64_RELEASE_F)"

# Download latest image if we don't have it
$(ARM64_XZ_MEMSTICK): $(ARM64_RELEASE_F)
	echo "Downloading the $(ARM64_RELEASE) compressed raw image"
	curl --progress-bar -Lo $@ $(ARM64_XZ_URL)

# Download latest image checksum if we don't have it
$(ARM64_XZ_CKSUM): $(ARM64_XZ_MEMSTICK)
	echo "Downloading checksum"
	curl -sLo - $(ARM64_XZ_CKSUM_URL) | grep aarch64-memstick.img.xz | awk '-F=' '{print $$2}' | tr -d ' ' > $@

# Generate a checksum to compare against downloaded checksum
$(ARM64_XZ_CKSUM_GEN): $(ARM64_XZ_CKSUM)
	echo "Generating checksum"
	sha512sum -b $(ARM64_XZ_MEMSTICK) | awk '{print $$1}' > $@

# Compare checksums
$(ARM64_XZ_CKSUM_CMP): $(ARM64_XZ_CKSUM) $(ARM64_XZ_CKSUM_GEN)
	echo "Comparing checksums"
	diff $^ > /dev/null || { \
	  echo "Downloaded checksum does not match generated checksum"; \
	  exit 1; \
	}
	touch $@

# Decompress image
# By default, xz extracts the file using the date inside the archive.
# We need to update the extracted file to the current date to avoid always re-extracting.
$(ARM64_MEMSTICK): $(ARM64_XZ_CKSUM_CMP)
	echo "Extracting memstick image"
	xz --verbose -kfd $@.xz
	touch $@

# Make an installer copy of the decompressed memstick image every time it is extracted or setup-arm64.sh is modified
# For some reason, cp is really slow to copy this 6GB file, but cat is only a few seconds
$(ARM64_RETRO): $(ARM64_MEMSTICK)
	echo "Creating a sparse compressed 8GB image"
	qemu-img create -f qcow2 -o compression_type=zstd,lazy_refcounts=on $@ 8G

# Execute $(ARM64_RETRO) goal and touch target only if $(ARM64_RETRO) file does not exist
# The $(ARM64_RETRO) changes every time it boots, whether or not any changes were made
$(ARM64_RETRO_EXISTS): setup-arm64.sh
	echo here
	[ -f "arm64.retro.qcow2" -a "arm64.retro.qcow2" -nt "setup-arm64.sh" ] || { \
	  echo y; \
	  $(MAKE) $(ARM64_RETRO); \
	  touch $@; \
	}

# Generate the edk2 file if:
# - It does not exist
# - It contains a different version than the current one
.PHONY: generate-edk2-release
generate-edk2-release:
	echo 'Checking edk2 release'
	[ -f "$(OVMF_RELEASE_F)" -a "`cat "$(OVMF_RELEASE_F)" 2> /dev/null`" = "$(OVMF_RELEASE)" ] || echo "$(OVMF_RELEASE)" > "$(OVMF_RELEASE_F)"

# Download the edk2 tar file
$(OVMF_TAR_XZ): $(OVMF_RELEASE_F)
	echo 'Downloading the $(OVMF_RELEASE) compressed archive'
	curl -Lo $@ $(OVMF_DOWNLOAD)

# Extract the AMD EFI code from edk2 tar file
$(ARM64_OVMF_CODE): $(OVMF_TAR_XZ)
	echo 'Extracting $(OVMF_TAR_AARCH64_CODE) from $< into $@'
	tar xfO $< $(OVMF_TAR_AARCH64_CODE) > $@

# Extract the AMD EFI vars from edk2 tar file
$(ARM64_OVMF_VARS): $(OVMF_TAR_XZ)
	echo 'Extracting $(OVMF_TAR_AARCH64_VARS) from $< into $@'
	tar xfO $< $(OVMF_TAR_AARCH64_VARS) > $@

# Modify the memstick image to install bootstrap.sh script
$(ARM64_RETRO_INST): $(ARM64_RETRO) $(ARM64_OVMF_CODE)
	echo
	echo '#### Configure copy of memstick image to auto install'
	echo
	echo '1. Remount root as read/write:'
	echo 'mount -u -w /'
	echo
	echo '2. Get network up'
	echo 'dhclient vtnet0'
	echo
	echo '3. Download script:'
	echo 'echo "get setup-arm64.sh" | tftp 10.0.2.2'
	echo
	echo '4. Run script:'
	echo 'sh /setup-arm64.sh'
	echo
	qemu-system-aarch64 \
	  -accel "$(QEMU_ACCEL)" \
	  -cpu host \
	  -M virt \
	  -m 1024 \
	  -boot menu=on,splash-time=0 \
	  -drive if=pflash,media=disk,file=$(ARM64_OVMF_CODE),cache=writethrough,format=raw \
	  -drive if=pflash,media=disk,file=$(ARM64_OVMF_VARS),cache=writethrough,format=raw \
	  -drive file=$(ARM64_MEMSTICK),format=raw,if=virtio \
	  -drive file=$(ARM64_RETRO),if=virtio \
	  -nic user,model=virtio-net-pci,tftp=. \
	  -device qemu-xhci \
	  -device usb-kbd \
	  -device usb-tablet \
	  -device virtio-gpu-pci \
	  -display cocoa
	touch $@

# -boot menu=on,splash-time=0 \

# Run the installed retro system
.PHONY: run
run:
	echo
	echo "Running installed system"
	qemu-system-aarch64 \
	  -accel "$(QEMU_ACCEL)" \
	  -cpu host \
	  -M virt \
	  -m 1024 \
	  -boot menu=on,splash-time=0 \
	  -drive if=pflash,media=disk,file=$(ARM64_OVMF_CODE),cache=writethrough,format=raw \
	  -drive if=pflash,media=disk,file=$(ARM64_OVMF_VARS),cache=writethrough,format=raw \
	  -drive file=$(ARM64_RETRO),file.locking=off,if=virtio \
	  -nic user,model=virtio-net-pci,tftp=. \
	  -device qemu-xhci \
	  -device usb-kbd \
	  -device usb-tablet \
	  -device virtio-gpu-pci \
	  -display cocoa \
	  -device virtio-sound-device \
	  -audiodev coreaudio,id=snd \
	  -device intel-hda,audiodev=snd

#	  -device intel-hda -device hda-output,audiodev=coreaudio \
#	  -audiodev coreaudio,id=coreaudio

#	  -device ich9-ahci,id=ich9-bus \
#	  -device ich9-intel-hda,id=sound0,bus=ich9-bus.0 \
#	  -device hda-duplex,bus=sound0.0,cad=0

# -device usb-host,vendorid=0x2222,productid=0x4010 \
#name "AC97", bus PCI, alias "ac97", desc "Intel 82801AA AC97 Audio"
#name "ES1370", bus PCI, alias "es1370", desc "ENSONIQ AudioPCI ES1370"
#name "hda-duplex", bus HDA, desc "HDA Audio Codec, duplex (line-out, line-in)"
#name "hda-micro", bus HDA, desc "HDA Audio Codec, duplex (speaker, microphone)"
#name "hda-output", bus HDA, desc "HDA Audio Codec, output-only (line-out)"
#name "ich9-intel-hda", bus PCI, desc "Intel HD Audio Controller (ich9)"
#name "intel-hda", bus PCI, desc "Intel HD Audio Controller (ich6)"
#name "usb-audio", bus usb-bus
#name "virtio-sound-device", bus virtio-bus
#name "virtio-sound-pci", bus PCI, alias "virtio-sound", desc "Virtio Sound"


.PHONY: reinstall
reinstall:
	rm -f $(ARM64_RETRO)

.PHONY: clean
clean:
	find . -maxdepth 1 -type f \( -name 'arm64*' -o -name '.arm64*' \) -a \! -name '$(ARM64_XZ_MEMSTICK)' -print0 | xargs -0 rm

.PHONY: push
push:
	git add -A
	git commit -m Changes
	git push

.PHONY: vars
vars:
	echo "ARM64_ISO_BASE_URL    = $(ARM64_ISO_BASE_URL)"
	echo "ARM64_RELEASE         = $(ARM64_RELEASE)"
	echo "ARM64_RELEASE_F       = $(ARM64_RELEASE_F)"
	echo "ARM64_XZ_URL          = $(ARM64_XZ_URL)"
	echo "ARM64_MEMSTICK        = $(ARM64_MEMSTICK)"
	echo "ARM64_XZ_MEMSTICK     = $(ARM64_XZ_MEMSTICK)"
	echo "ARM64_XZ_CKSUM_URL    = $(ARM64_XZ_CKSUM_URL)"
	echo "ARM64_XZ_CKSUM        = $(ARM64_XZ_CKSUM)"
	echo "ARM64_XZ_CKSUM_GEN    = $(ARM64_XZ_CKSUM_GEN)"
	echo "ARM64_XZ_CKSUM_CMP    = $(ARM64_XZ_CKSUM_CMP)"
	echo "ARM64_RETRO      = $(ARM64_RETRO)"
	echo "OVMF_REPO             = $(OVMF_REPO)"
	echo "OVMF_API              = $(OVMF_API)"
	echo "OVMF_RELEASE          = $(OVMF_RELEASE)"
	echo "OVMF_RELEASE_F        = $(OVMF_RELEASE_F)"
	echo "OVMF_DOWNLOAD         = $(OVMF_DOWNLOAD)"
	echo "OVMF_TAR_XZ           = $(OVMF_TAR_XZ)"
	echo "OVMF_TAR_AARCH64_CODE = $(OVMF_TAR_AARCH64_CODE)"
	echo "OVMF_TAR_AARCH64_VARS = $(OVMF_TAR_AARCH64_VARS)"
	echo "ARM64_OVMF_CODE       = $(ARM64_OVMF_CODE)"
	echo "ARM64_OVMF_VARS       = $(ARM64_OVMF_VARS)"
	echo "ARM64_RETRO_INST      = $(ARM64_RETRO_INST)"
	echo "QEMU_ACCEL_HVF        = $(QEMU_ACCEL_HVF)"
	echo "QEMU_ACCEL_WHPX       = $(QEMU_ACCEL_WHPX)"
	echo "QEMU_ACCEL_KVM        = $(QEMU_ACCEL_KVM)"
	echo "QEMU_ACCEL            = $(QEMU_ACCEL)"
