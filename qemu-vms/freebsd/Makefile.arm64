# // SPDX-License-Identifier: Apache-2.0

# Build a FreeBSD aarch64 bootable image with the following basic steps:
# - Determine latest release of FreeBSD memstick image
# - Download latest release and hash file
# - Generate a hash file, and commpare against downloaded hash file
# - Make a copy of memstick image
# - EFI boot copy of memstick
# - Modify memstick image so that it has autologin, and a bootstrap script
# - Run bootstrap script to modify a second drive that is an installer
# - Auto powers off once installer is setup
# - EFI boot installer image to install into a test image
# - User manually runs installer, and powers off
# - EFI boot test image to verify it boots up, user can login on and poweroff

# Execute all recipe lines in one shell
.ONESHELL:

# Turn off default rules
.SUFFIXES:

# We need a target to determine the latest release version of FreeBSD
# This is a nuisance because there may be a beta version that is newer than the current release
# EG:
# We grab contents of https://download.freebsd.org/releases/arm64/aarch64/ISO-IMAGES:
#
# 12.4/
# 13.2/
# 13.3/
# 14.0/
# 14.1/
#
# But if we list contents of https://download.freebsd.org/releases/arm64/aarch64/ISO-IMAGES/14.1, we see it is a beta:
# FreeBSD-14.1-BETA1-arm64-aarch64-memstick.img.xz
#
# So we need to fall back on the previous 14.0 version:
# FreeBSD-14.0-RELEASE-arm64-aarch64-memstick.img.xz
#
# Eventually, the 14.1 beta will be replaced by a release, and the script will use that instead if 14.0

# URL to get available versions of FreeBSD
ARM64_ISO_BASE_URL := https://download.freebsd.org/releases/arm64/aarch64/ISO-IMAGES

# Define a script to get the latest x86 RELEASE version
define ARM64_GET_RELEASE
for version in $$(curl -sL $(ARM64_ISO_BASE_URL) | grep '<a href="[0-9]' | sed -r 's,.*href="([^/]*)/.*,\1,' | sort -rV); do
	[ $$(curl -sL $(ARM64_ISO_BASE_URL)/$$version | grep 'href="FreeBSD.*RELEASE' | wc -l) -gt 0 ] || continue;
	echo $$version;
	break;
done
endef

# Define release vars
ARM64_RELEASE         := $(shell $(ARM64_GET_RELEASE))
ARM64_RELEASE_F       := .arm64.release
ARM64_XZ_URL          := $(ARM64_ISO_BASE_URL)/$(ARM64_RELEASE)/FreeBSD-$(ARM64_RELEASE)-RELEASE-arm64-aarch64-memstick.img.xz
ARM64_MEMSTICK        := .arm64-memstick.img
ARM64_XZ_MEMSTICK     := $(ARM64_MEMSTICK).xz
ARM64_XZ_CKSUM_URL    := $(ARM64_ISO_BASE_URL)/$(ARM64_RELEASE)/CHECKSUM.SHA512-FreeBSD-$(ARM64_RELEASE)-RELEASE-arm64-aarch64
ARM64_XZ_CKSUM        := .arm64.sha512
ARM64_XZ_CKSUM_GEN    := $(ARM64_XZ_CKSUM).gen
ARM64_XZ_CKSUM_CMP    := $(ARM64_XZ_CKSUM).cmp
ARM64_MEMSTICK_BOOT   := .arm64.boot.img
ARM64_MEMSTICK_CONF   := .arm64.conf
ARM64_MEMSTICK_INST   := .arm64.inst
ARM64_MEMSTICK_TEST   := .arm64.test
OVMF_REPO             := rust-osdev/ovmf-prebuilt
OVMF_API              := https://api.github.com/repos/$(OVMF_REPO)
OVMF_RELEASE          := $(shell curl -s $(OVMF_API)/releases | jq -r '.[].tag_name' | grep stable | head -n 1)
OVMF_RELEASE_F        := .edk2.release
OVMF_DOWNLOAD         := https://github.com/$(OVMF_REPO)/releases/download/$(OVMF_RELEASE)/$(OVMF_RELEASE)-bin.tar.xz
OVMF_TAR_XZ           := .edk2.tar.xz
OVMF_TAR_AARCH64_CODE := $(OVMF_RELEASE)-bin/aarch64/code.fd
OVMF_TAR_AARCH64_VARS := $(OVMF_RELEASE)-bin/aarch64/vars.fd
ARM64_OVMF_CODE       := .arm64.OVMF_CODE.fd
ARM64_OVMF_VARS       := .arm64.OVMF_VARS.fd


# Define other vars
COMMA                        := ,
QEMU_ACCEL_HVF               := $(shell qemu-system-aarch64 -accel help | grep hvf)
QEMU_ACCEL_WHPX              := $(shell qemu-system-aarch64 -accel help | grep whpx)
QEMU_ACCEL_KVM               := $(shell qemu-system-aarch64 -accel help | grep kvm)
QEMU_ACCEL                   := $(if $(QEMU_ACCEL_HVF),hvf,$(if $(QEMU_ACCEL_WHPX),whpx$(COMMA)kernel-irqchip=off,$(if $(QEMU_ACCEL_KVM),kvm,tcg)))
ARM64_IMAGE_INSTALL          := arm64.install.img
ARM64_IMAGE_TEST             := arm64.test.img
ARM64_IMAGE_TEST2            := arm64.test2.img

# Silent by default
# Run "make VERBOSE=1 ..." to show output of each recipe invoked
ifndef VERBOSE
.SILENT:
endif

# Default target
.PHONY: all
all: generate-freebsd-release $(ARM64_MEMSTICK_TEST)

# Generate the release file if:
# - It does not exist
# - It contains a different version that the current one
.PHONY: generate-freebsd-release
generate-freebsd-release:
	echo 'Checking FreeBSD release'
	[ -f "$(ARM64_RELEASE_F)" -a "`cat "$(ARM64_RELEASE_F)" 2> /dev/null`" = "$(ARM64_RELEASE)" ] || echo "$(ARM64_RELEASE)" > "$(ARM64_RELEASE_F)"

# Download latest image if we don't have it
$(ARM64_XZ_MEMSTICK): $(ARM64_RELEASE_F)
	echo "Downloading the $(ARM64_RELEASE) compressed raw image"
	curl --progress-bar -Lo $@ $(ARM64_XZ_URL)

# Download latest image checksum if we don't have it
$(ARM64_XZ_CKSUM): $(ARM64_XZ_MEMSTICK)
	echo "Downloading checksum"
	curl -sLo - $(ARM64_XZ_CKSUM_URL) | grep aarch64-memstick.img.xz | awk '-F=' '{print $$2}' | tr -d ' ' > $@

# Generate a checksum to compare against downloaded checksum
$(ARM64_XZ_CKSUM_GEN): $(ARM64_XZ_CKSUM)
	echo "Generating checksum"
	sha512sum -b $(ARM64_XZ_MEMSTICK) | awk '{print $$1}' > $@

# Compare checksums
$(ARM64_XZ_CKSUM_CMP): $(ARM64_XZ_CKSUM) $(ARM64_XZ_CKSUM_GEN)
	echo "Comparing checksums"
	diff $^ > /dev/null || { \
	  echo "Downloaded checksum does not match generated checksum"; \
	  exit 1; \
	}
	touch $@

# Decompress image
# By default, xz extracts the file using the date inside the archive.
# We need to update the extracted file to the current date to avoid always re-extracting.
$(ARM64_MEMSTICK): $(ARM64_XZ_CKSUM_CMP)
	echo "Extracting memstick image"
	xz --verbose -kfd $@.xz
	touch $@

# Make an installer copy of the decompressed memstick image every time it is extracted or bootstrap.sh is modified
# For some reason, cp is really slow to copy this 6GB file, but cat is only a few seconds
$(ARM64_MEMSTICK_BOOT): $(ARM64_MEMSTICK) bootstrap.sh
	echo "Copying memstick image for manual modification"
	cat $< > $@

# Create the install image
$(ARM64_IMAGE_INSTALL):
	echo 'Creating install image $@'
	qemu-img create -f raw $@ 8G

# Generate the edk2 file if:
# -It does not exist
# - It contains a different version than the current one
.PHONY: generate-edk2-release
generate-edk2-release:
	echo 'Checking edk2 release'
	[ -f "$(OVMF_RELEASE_F)" -a "`cat "$(OVMF_RELEASE_F)" 2> /dev/null`" = "$(OVMF_RELEASE)" ] || echo "$(OVMF_RELEASE)" > "$(OVMF_RELEASE_F)"

# Download the edk2 tar file
$(OVMF_TAR_XZ): $(OVMF_RELEASE_F)
	echo 'Downloading the $(OVMF_RELEASE) compressed archive'
	curl -Lo $@ $(OVMF_DOWNLOAD)

# Extract the AMD EFI code from edk2 tar file
$(ARM64_OVMF_CODE): $(OVMF_TAR_XZ)
	echo 'Extracting $(OVMF_TAR_AARCH64_CODE) from $< into $@'
	tar xfO $< $(OVMF_TAR_AARCH64_CODE) > $@

# Extract the AMD EFI vars from edk2 tar file
$(ARM64_OVMF_VARS): $(OVMF_TAR_XZ)
	echo 'Extracting $(OVMF_TAR_AARCH64_VARS) from $< into $@'
	tar xfO $< $(OVMF_TAR_AARCH64_VARS) > $@

# Modify the memstick image to install bootstrap.sh script
$(ARM64_MEMSTICK_CONF): $(ARM64_MEMSTICK_BOOT) $(ARM64_IMAGE_INSTALL) generate-edk2-release $(ARM64_OVMF_CODE) $(ARM64_OVMF_VARS) bootstrap-setup.sh setup.sh
	echo
	echo '#### Configure copy of memstick image to auto install'
	echo
	echo '1. Remount root as read/write:'
	echo 'mount -u -w /'
	echo
	echo '2. Get network up'
	echo 'dhclient vtnet0'
	echo
	echo '3. Download bootstrap script:'
	echo 'echo "get bootstrap.sh" | tftp 10.0.2.2'
	echo
	echo '4. Run bootstrap.sh:'
	echo 'sh /bootstrap.sh'
	echo
	qemu-system-aarch64 \
	  -accel "$(QEMU_ACCEL)" \
	  -cpu host \
	  -M virt \
	  -m 1024 \
	  -boot c \
	  -drive if=pflash,media=disk,file=$(ARM64_OVMF_CODE),cache=writethrough,format=raw \
	  -drive if=pflash,media=disk,file=$(ARM64_OVMF_VARS),cache=writethrough,format=raw \
	  -drive file=$(ARM64_MEMSTICK_BOOT),format=raw,file.locking=off,if=virtio \
	  -drive file=$(ARM64_IMAGE_INSTALL),format=raw,if=virtio \
	  -nic user,model=virtio-net-pci,tftp=. \
	  -device virtio-gpu-pci \
	  -device qemu-xhci \
	  -device usb-kbd \
	  -device usb-tablet \
	  -display cocoa
	touch $@

$(ARM64_IMAGE_TEST):
	echo 'Creating image $@'
	qemu-img create -f raw $@ 8G

# Install into a test image using the install image with real world devices, to manually test installing to another drive
# Touches both ARM64_MEMSTICK_CONF file and target file:
# - The ARM64_IMAGE_INSTALL is modified by the process of starting it up, as it is a regular read/write filesystem
# - Causes the ARM64_IMAGE_INSTALL to have a newer date than ARM64_MEMSTICK_CONF
# - Causes the ARM64_MEMSTICK_CONF target to re-execute on next make, since it is older than the ARM64_IMAGE_INSTALL prereq
# By touching the ARM64_MEMSTICK_CONF file after QEMU quits, it has a newer date than the ARM64_IMAGE_INSTALL prereq,
# which prevents endless make loop
$(ARM64_MEMSTICK_INST): $(ARM64_MEMSTICK_CONF) $(ARM64_IMAGE_TEST)
	echo
	echo '#### Use modified memstick image to auto install into a test image'
	echo
	echo 'When prompt appears, login as root (password toor) and run /setup.sh -d ada1'
	echo 'The default is to have swap, a label of hd, a pool named zroot, UTC timezone'
	echo
	echo 'you can run /setup.sh -d ada1 [ -l label ] [ -n ] [ -p poolname ] [ -a ] [-t timezone]'
	echo "Where:"
	echo "-l sets a different label, -n means no swap, -p poolname provides an alternate pool name (don't use zinstall),"
	echo "-a means autologin, and -t sets a different timezone"
	echo
	echo 'When the setup completes, run poweroff to quit and test the target image under EFI'
	qemu-system-aarch64 \
	  -accel "$(QEMU_ACCEL)" \
	  -cpu qemu64 \
	  -m 1024 \
	  -boot c \
	  -drive file=$(ARM64_IMAGE_INSTALL),format=raw,id=disk0,cache=writeback,if=none \
	  -drive file=$(ARM64_IMAGE_TEST),format=raw,id=disk1,cache=writeback,if=none \
	  -device ahci,id=ahci \
	  -device ide-hd,drive=disk0,bus=ahci.0 \
	  -device ide-hd,drive=disk1,bus=ahci.1 \
	  -nic user,model=virtio-net-pci
	touch $< $@

.PHONY: $(ARM64_IMAGE_TEST2)
$(ARM64_IMAGE_TEST2):
	echo 'Creating image $@'
	qemu-img create -f raw $@ 8G

# Test the test image boots
# Touches ARM64_MEMSTICK_INST, ARM64_MEMSTICK_CONF, and target file for same reasons as above for ARM64_MEMSTICK_INST target
$(ARM64_MEMSTICK_TEST): $(ARM64_MEMSTICK_INST) $(ARM64_IMAGE_TEST2)
	echo
	echo '#### Boot test image, with same network config as auto install image'
	echo
	echo 'When login prompt appears, login as root, password is toor'
	echo 'Both network cards should work, where 192.168.0.1 and 192.168.1.1 are the gateways'
	echo "tftp can be used on 192.168.1.2"
	echo
	qemu-system-aarch64 \
		-accel "$(QEMU_ACCEL)" \
		-cpu qemu64 \
		-m 1024 \
		-boot c \
		-drive if=pflash,media=disk,file=$(ARM64_OVMF_CODE),cache=writethrough,format=raw \
		-drive if=pflash,media=disk,file=$(ARM64_OVMF_VARS),cache=writethrough,format=raw \
		-drive file=$(ARM64_IMAGE_TEST),format=raw,id=disk0,if=none \
		-drive file=$(ARM64_IMAGE_TEST2),format=raw,id=disk1,if=none \
		-device ahci,id=ahci \
		-device ide-hd,drive=disk0,bus=ahci.0 \
		-device ide-hd,drive=disk1,bus=ahci.1 \
		-nic user,model=e1000,net=192.168.0.0/24,dhcpstart=192.168.0.1 \
		-nic user,model=rtl8139,net=192.168.1.0/24,dhcpstart=192.168.1.1,tftp=.
	touch $< $(ARM64_MEMSTICK_CONF) $@

.PHONY: recopy
recopy:
	rm -f $(ARM64_MEMSTICK_BOOT)
	$(MAKE)

.PHONY: reconfig
reconfig:
	rm -f $(ARM64_MEMSTICK_CONF) $(ARM64_MEMSTICK_INST) $(ARM64_MEMSTICK_TEST)
	$(MAKE)

.PHONY: reinstall
reinstall:
	rm -f $(ARM64_MEMSTICK_INST) $(ARM64_MEMSTICK_TEST)
	$(MAKE)

.PHONY: retest
retest:
	rm -f $(ARM64_MEMSTICK_TEST)
	$(MAKE)

.PHONY: clean
clean:
	find . -maxdepth 1 -type f \( -name 'arm64*' -o -name '.arm64*' \) -a \! \( -name '$(ARM64_RELEASE_F)' -o -name '$(ARM64_XZ_MEMSTICK)' \) -print0 | xargs -0 rm

.PHONY: push
push:
	git add -A
	git commit -m Changes
	git push

.PHONY: vars
vars:
	echo "ARM64_ISO_BASE_URL    = $(ARM64_ISO_BASE_URL)"
	echo "ARM64_RELEASE         = $(ARM64_RELEASE)"
	echo "ARM64_RELEASE_F       = $(ARM64_RELEASE_F)"
	echo "ARM64_XZ_URL          = $(ARM64_XZ_URL)"
	echo "ARM64_MEMSTICK        = $(ARM64_MEMSTICK)"
	echo "ARM64_XZ_MEMSTICK     = $(ARM64_XZ_MEMSTICK)"
	echo "ARM64_XZ_CKSUM_URL    = $(ARM64_XZ_CKSUM_URL)"
	echo "ARM64_XZ_CKSUM        = $(ARM64_XZ_CKSUM)"
	echo "ARM64_XZ_CKSUM_GEN    = $(ARM64_XZ_CKSUM_GEN)"
	echo "ARM64_XZ_CKSUM_CMP    = $(ARM64_XZ_CKSUM_CMP)"
	echo "ARM64_MEMSTICK_BOOT   = $(ARM64_MEMSTICK_BOOT)"
	echo "ARM64_MEMSTICK_CONF   = $(ARM64_MEMSTICK_CONF)"
	echo "ARM64_MEMSTICK_INST   = $(ARM64_MEMSTICK_INST)"
	echo "ARM64_MEMSTICK_TEST   = $(ARM64_MEMSTICK_TEST)"
	echo "OVMF_REPO             = $(OVMF_REPO)"
	echo "OVMF_API              = $(OVMF_API)"
	echo "OVMF_RELEASE          = $(OVMF_RELEASE)"
	echo "OVMF_RELEASE_F        = $(OVMF_RELEASE_F)"
	echo "OVMF_DOWNLOAD         = $(OVMF_DOWNLOAD)"
	echo "OVMF_TAR_XZ           = $(OVMF_TAR_XZ)"
	echo "OVMF_TAR_AARCH64_CODE = $(OVMF_TAR_AARCH64_CODE)"
	echo "OVMF_TAR_AARCH64_VARS = $(OVMF_TAR_AARCH64_VARS)"
	echo "ARM64_OVMF_CODE       = $(ARM64_OVMF_CODE)"
	echo "ARM64_OVMF_VARS       = $(ARM64_OVMF_VARS)"
	echo "QEMU_ACCEL_HVF        = $(QEMU_ACCEL_HVF)"
	echo "QEMU_ACCEL_WHPX       = $(QEMU_ACCEL_WHPX)"
	echo "QEMU_ACCEL_KVM        = $(QEMU_ACCEL_KVM)"
	echo "QEMU_ACCEL            = $(QEMU_ACCEL)"
	echo "ARM64_IMAGE_INSTALL   = $(ARM64_IMAGE_INSTALL)"
	echo "ARM64_IMAGE_TEST      = $(ARM64_IMAGE_TEST)"
	echo "ARM64_IMAGE_TEST2     = $(ARM64_IMAGE_TEST2)"
